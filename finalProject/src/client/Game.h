// **********************************************************************
//
// Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.1
//
// <auto-generated>
//
// Generated from file `Game.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Game_h__
#define __Game_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Game
{

class GameState;
class GameStatePrx;

}

namespace Game
{

struct Pair
{
    int x;
    int y;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(x, y);
    }
};

using Line = ::std::vector<Pair>;

using LineVector = ::std::vector<Line>;

using ColorVector = ::std::vector<int>;

struct GameInfo
{
    int numplayers;
    int currplayer;
    bool inprogress;
    bool changedturn;
    ::std::string word;
    ::std::string hint;
    int time;
    int round;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const int&, const int&, const bool&, const bool&, const ::std::string&, const ::std::string&, const int&, const int&> ice_tuple() const
    {
        return std::tie(numplayers, currplayer, inprogress, changedturn, word, hint, time, round);
    }
};

struct Player
{
    int score;
    ::std::string name;
    ::std::string lastguess;
    bool guessed;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const int&, const ::std::string&, const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(score, name, lastguess, guessed);
    }
};

using Players = ::std::vector<Player>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Game
{

class GameState : public virtual ::Ice::Object
{
public:

    using ProxyType = GameStatePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void printString(::std::string s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_printString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int AddPlayer(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_AddPlayer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void IncrementScore(int id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_IncrementScore(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int GetScore(int id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetScore(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int GetNumPlayers(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetNumPlayers(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual GameInfo GetGameInfo(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetGameInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LineVector GetLines(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DrawLines(LineVector lines, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_DrawLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ColorVector GetColors(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetColors(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DrawColors(ColorVector colors, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_DrawColors(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool CheckWord(::std::string word, int id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_CheckWord(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Players GetPlayers(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetPlayers(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Game
{

class GameStatePrx : public virtual ::Ice::Proxy<GameStatePrx, ::Ice::ObjectPrx>
{
public:

    void printString(const ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GameStatePrx::_iceI_printString, s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto printStringAsync(const ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GameStatePrx::_iceI_printString, s, context);
    }

    ::std::function<void()>
    printStringAsync(const ::std::string& s,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &GameStatePrx::_iceI_printString, s, context);
    }

    /// \cond INTERNAL
    void _iceI_printString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    int AddPlayer(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &GameStatePrx::_iceI_AddPlayer, name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto AddPlayerAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &GameStatePrx::_iceI_AddPlayer, name, context);
    }

    ::std::function<void()>
    AddPlayerAsync(const ::std::string& name,
                   ::std::function<void(int)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &GameStatePrx::_iceI_AddPlayer, name, context);
    }

    /// \cond INTERNAL
    void _iceI_AddPlayer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void IncrementScore(int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GameStatePrx::_iceI_IncrementScore, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto IncrementScoreAsync(int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GameStatePrx::_iceI_IncrementScore, id, context);
    }

    ::std::function<void()>
    IncrementScoreAsync(int id,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &GameStatePrx::_iceI_IncrementScore, id, context);
    }

    /// \cond INTERNAL
    void _iceI_IncrementScore(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    int GetScore(int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &GameStatePrx::_iceI_GetScore, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetScoreAsync(int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &GameStatePrx::_iceI_GetScore, id, context);
    }

    ::std::function<void()>
    GetScoreAsync(int id,
                  ::std::function<void(int)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &GameStatePrx::_iceI_GetScore, id, context);
    }

    /// \cond INTERNAL
    void _iceI_GetScore(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, int, const ::Ice::Context&);
    /// \endcond

    int GetNumPlayers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &GameStatePrx::_iceI_GetNumPlayers, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetNumPlayersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &GameStatePrx::_iceI_GetNumPlayers, context);
    }

    ::std::function<void()>
    GetNumPlayersAsync(::std::function<void(int)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &GameStatePrx::_iceI_GetNumPlayers, context);
    }

    /// \cond INTERNAL
    void _iceI_GetNumPlayers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    GameInfo GetGameInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<GameInfo>(true, this, &GameStatePrx::_iceI_GetGameInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetGameInfoAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<GameInfo>>().get_future())
    {
        return _makePromiseOutgoing<GameInfo, P>(false, this, &GameStatePrx::_iceI_GetGameInfo, context);
    }

    ::std::function<void()>
    GetGameInfoAsync(::std::function<void(GameInfo)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<GameInfo>(response, ex, sent, this, &GameStatePrx::_iceI_GetGameInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_GetGameInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<GameInfo>>&, const ::Ice::Context&);
    /// \endcond

    LineVector GetLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<LineVector>(true, this, &GameStatePrx::_iceI_GetLines, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetLinesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<LineVector>>().get_future())
    {
        return _makePromiseOutgoing<LineVector, P>(false, this, &GameStatePrx::_iceI_GetLines, context);
    }

    ::std::function<void()>
    GetLinesAsync(::std::function<void(LineVector)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<LineVector>(response, ex, sent, this, &GameStatePrx::_iceI_GetLines, context);
    }

    /// \cond INTERNAL
    void _iceI_GetLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<LineVector>>&, const ::Ice::Context&);
    /// \endcond

    void DrawLines(const LineVector& lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GameStatePrx::_iceI_DrawLines, lines, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto DrawLinesAsync(const LineVector& lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GameStatePrx::_iceI_DrawLines, lines, context);
    }

    ::std::function<void()>
    DrawLinesAsync(const LineVector& lines,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &GameStatePrx::_iceI_DrawLines, lines, context);
    }

    /// \cond INTERNAL
    void _iceI_DrawLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const LineVector&, const ::Ice::Context&);
    /// \endcond

    ColorVector GetColors(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ColorVector>(true, this, &GameStatePrx::_iceI_GetColors, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetColorsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ColorVector>>().get_future())
    {
        return _makePromiseOutgoing<ColorVector, P>(false, this, &GameStatePrx::_iceI_GetColors, context);
    }

    ::std::function<void()>
    GetColorsAsync(::std::function<void(ColorVector)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ColorVector>(response, ex, sent, this, &GameStatePrx::_iceI_GetColors, context);
    }

    /// \cond INTERNAL
    void _iceI_GetColors(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ColorVector>>&, const ::Ice::Context&);
    /// \endcond

    void DrawColors(const ColorVector& colors, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GameStatePrx::_iceI_DrawColors, colors, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto DrawColorsAsync(const ColorVector& colors, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GameStatePrx::_iceI_DrawColors, colors, context);
    }

    ::std::function<void()>
    DrawColorsAsync(const ColorVector& colors,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &GameStatePrx::_iceI_DrawColors, colors, context);
    }

    /// \cond INTERNAL
    void _iceI_DrawColors(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ColorVector&, const ::Ice::Context&);
    /// \endcond

    bool CheckWord(const ::std::string& word, int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GameStatePrx::_iceI_CheckWord, word, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto CheckWordAsync(const ::std::string& word, int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GameStatePrx::_iceI_CheckWord, word, id, context);
    }

    ::std::function<void()>
    CheckWordAsync(const ::std::string& word, int id,
                   ::std::function<void(bool)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &GameStatePrx::_iceI_CheckWord, word, id, context);
    }

    /// \cond INTERNAL
    void _iceI_CheckWord(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    Players GetPlayers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Players>(true, this, &GameStatePrx::_iceI_GetPlayers, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetPlayersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Players>>().get_future())
    {
        return _makePromiseOutgoing<Players, P>(false, this, &GameStatePrx::_iceI_GetPlayers, context);
    }

    ::std::function<void()>
    GetPlayersAsync(::std::function<void(Players)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<Players>(response, ex, sent, this, &GameStatePrx::_iceI_GetPlayers, context);
    }

    /// \cond INTERNAL
    void _iceI_GetPlayers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Players>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    GameStatePrx() = default;
    friend ::std::shared_ptr<GameStatePrx> IceInternal::createProxy<GameStatePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Game::Pair>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Game::Pair, S>
{
    static void read(S* istr, ::Game::Pair& v)
    {
        istr->readAll(v.x, v.y);
    }
};

template<>
struct StreamableTraits<::Game::GameInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Game::GameInfo, S>
{
    static void read(S* istr, ::Game::GameInfo& v)
    {
        istr->readAll(v.numplayers, v.currplayer, v.inprogress, v.changedturn, v.word, v.hint, v.time, v.round);
    }
};

template<>
struct StreamableTraits<::Game::Player>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Game::Player, S>
{
    static void read(S* istr, ::Game::Player& v)
    {
        istr->readAll(v.score, v.name, v.lastguess, v.guessed);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Game
{

using GameStatePtr = ::std::shared_ptr<GameState>;
using GameStatePrxPtr = ::std::shared_ptr<GameStatePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Game
{

class GameState;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Game::GameState>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Game::GameState*);
/// \endcond

}

}

namespace Game
{

class GameState;
/// \cond INTERNAL
::Ice::Object* upCast(GameState*);
/// \endcond
typedef ::IceInternal::Handle< GameState> GameStatePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Game::GameState> GameStatePrx;
typedef GameStatePrx GameStatePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(GameStatePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Game
{

struct Pair
{
    ::Ice::Int x;
    ::Ice::Int y;

    bool operator==(const Pair& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Pair& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Pair& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Pair& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Pair& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Pair& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Game::Pair> Line;

typedef ::std::vector<Game::Line> LineVector;

typedef ::std::vector<Ice::Int> ColorVector;

struct GameInfo
{
    ::Ice::Int numplayers;
    ::Ice::Int currplayer;
    bool inprogress;
    bool changedturn;
    ::std::string word;
    ::std::string hint;
    ::Ice::Int time;
    ::Ice::Int round;

    bool operator==(const GameInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(numplayers != rhs_.numplayers)
        {
            return false;
        }
        if(currplayer != rhs_.currplayer)
        {
            return false;
        }
        if(inprogress != rhs_.inprogress)
        {
            return false;
        }
        if(changedturn != rhs_.changedturn)
        {
            return false;
        }
        if(word != rhs_.word)
        {
            return false;
        }
        if(hint != rhs_.hint)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(round != rhs_.round)
        {
            return false;
        }
        return true;
    }

    bool operator<(const GameInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(numplayers < rhs_.numplayers)
        {
            return true;
        }
        else if(rhs_.numplayers < numplayers)
        {
            return false;
        }
        if(currplayer < rhs_.currplayer)
        {
            return true;
        }
        else if(rhs_.currplayer < currplayer)
        {
            return false;
        }
        if(inprogress < rhs_.inprogress)
        {
            return true;
        }
        else if(rhs_.inprogress < inprogress)
        {
            return false;
        }
        if(changedturn < rhs_.changedturn)
        {
            return true;
        }
        else if(rhs_.changedturn < changedturn)
        {
            return false;
        }
        if(word < rhs_.word)
        {
            return true;
        }
        else if(rhs_.word < word)
        {
            return false;
        }
        if(hint < rhs_.hint)
        {
            return true;
        }
        else if(rhs_.hint < hint)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(round < rhs_.round)
        {
            return true;
        }
        else if(rhs_.round < round)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const GameInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const GameInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const GameInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const GameInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Player
{
    ::Ice::Int score;
    ::std::string name;
    ::std::string lastguess;
    bool guessed;

    bool operator==(const Player& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(score != rhs_.score)
        {
            return false;
        }
        if(name != rhs_.name)
        {
            return false;
        }
        if(lastguess != rhs_.lastguess)
        {
            return false;
        }
        if(guessed != rhs_.guessed)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Player& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(score < rhs_.score)
        {
            return true;
        }
        else if(rhs_.score < score)
        {
            return false;
        }
        if(name < rhs_.name)
        {
            return true;
        }
        else if(rhs_.name < name)
        {
            return false;
        }
        if(lastguess < rhs_.lastguess)
        {
            return true;
        }
        else if(rhs_.lastguess < lastguess)
        {
            return false;
        }
        if(guessed < rhs_.guessed)
        {
            return true;
        }
        else if(rhs_.guessed < guessed)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Player& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Player& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Player& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Player& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Game::Player> Players;

}

namespace Game
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_printString.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_printString.
 */
class Callback_GameState_printString_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_printString_Base> Callback_GameState_printStringPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_AddPlayer.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_AddPlayer.
 */
class Callback_GameState_AddPlayer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_AddPlayer_Base> Callback_GameState_AddPlayerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_IncrementScore.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_IncrementScore.
 */
class Callback_GameState_IncrementScore_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_IncrementScore_Base> Callback_GameState_IncrementScorePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_GetScore.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetScore.
 */
class Callback_GameState_GetScore_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_GetScore_Base> Callback_GameState_GetScorePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_GetNumPlayers.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetNumPlayers.
 */
class Callback_GameState_GetNumPlayers_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_GetNumPlayers_Base> Callback_GameState_GetNumPlayersPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_GetGameInfo.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetGameInfo.
 */
class Callback_GameState_GetGameInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_GetGameInfo_Base> Callback_GameState_GetGameInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_GetLines.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetLines.
 */
class Callback_GameState_GetLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_GetLines_Base> Callback_GameState_GetLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_DrawLines.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_DrawLines.
 */
class Callback_GameState_DrawLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_DrawLines_Base> Callback_GameState_DrawLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_GetColors.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetColors.
 */
class Callback_GameState_GetColors_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_GetColors_Base> Callback_GameState_GetColorsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_DrawColors.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_DrawColors.
 */
class Callback_GameState_DrawColors_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_DrawColors_Base> Callback_GameState_DrawColorsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_CheckWord.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_CheckWord.
 */
class Callback_GameState_CheckWord_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_CheckWord_Base> Callback_GameState_CheckWordPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Game::GameState::begin_GetPlayers.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetPlayers.
 */
class Callback_GameState_GetPlayers_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameState_GetPlayers_Base> Callback_GameState_GetPlayersPtr;

}

namespace IceProxy
{

namespace Game
{

class GameState : public virtual ::Ice::Proxy<GameState, ::IceProxy::Ice::Object>
{
public:

    void printString(const ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_printString(_iceI_begin_printString(s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_printString(s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& s, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& s, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(s, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& s, const ::Game::Callback_GameState_printStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& s, const ::Ice::Context& context, const ::Game::Callback_GameState_printStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(s, context, cb, cookie);
    }

    void end_printString(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_printString(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int AddPlayer(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_AddPlayer(_iceI_begin_AddPlayer(name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_AddPlayer(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_AddPlayer(name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_AddPlayer(const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddPlayer(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AddPlayer(const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddPlayer(name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AddPlayer(const ::std::string& name, const ::Game::Callback_GameState_AddPlayerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddPlayer(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AddPlayer(const ::std::string& name, const ::Ice::Context& context, const ::Game::Callback_GameState_AddPlayerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddPlayer(name, context, cb, cookie);
    }

    ::Ice::Int end_AddPlayer(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_AddPlayer(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void IncrementScore(::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_IncrementScore(_iceI_begin_IncrementScore(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_IncrementScore(::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_IncrementScore(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_IncrementScore(::Ice::Int id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IncrementScore(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IncrementScore(::Ice::Int id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IncrementScore(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IncrementScore(::Ice::Int id, const ::Game::Callback_GameState_IncrementScorePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IncrementScore(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IncrementScore(::Ice::Int id, const ::Ice::Context& context, const ::Game::Callback_GameState_IncrementScorePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IncrementScore(id, context, cb, cookie);
    }

    void end_IncrementScore(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_IncrementScore(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int GetScore(::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetScore(_iceI_begin_GetScore(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetScore(::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetScore(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetScore(::Ice::Int id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScore(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScore(::Ice::Int id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScore(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScore(::Ice::Int id, const ::Game::Callback_GameState_GetScorePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScore(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScore(::Ice::Int id, const ::Ice::Context& context, const ::Game::Callback_GameState_GetScorePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScore(id, context, cb, cookie);
    }

    ::Ice::Int end_GetScore(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetScore(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int GetNumPlayers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetNumPlayers(_iceI_begin_GetNumPlayers(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetNumPlayers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetNumPlayers(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetNumPlayers(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetNumPlayers(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetNumPlayers(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetNumPlayers(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetNumPlayers(const ::Game::Callback_GameState_GetNumPlayersPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetNumPlayers(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetNumPlayers(const ::Ice::Context& context, const ::Game::Callback_GameState_GetNumPlayersPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetNumPlayers(context, cb, cookie);
    }

    ::Ice::Int end_GetNumPlayers(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetNumPlayers(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Game::GameInfo GetGameInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetGameInfo(_iceI_begin_GetGameInfo(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetGameInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetGameInfo(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetGameInfo(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetGameInfo(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGameInfo(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetGameInfo(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGameInfo(const ::Game::Callback_GameState_GetGameInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetGameInfo(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGameInfo(const ::Ice::Context& context, const ::Game::Callback_GameState_GetGameInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetGameInfo(context, cb, cookie);
    }

    ::Game::GameInfo end_GetGameInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetGameInfo(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Game::LineVector GetLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetLines(_iceI_begin_GetLines(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetLines(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetLines(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLines(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLines(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLines(const ::Game::Callback_GameState_GetLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLines(const ::Ice::Context& context, const ::Game::Callback_GameState_GetLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLines(context, cb, cookie);
    }

    ::Game::LineVector end_GetLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetLines(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void DrawLines(const ::Game::LineVector& lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_DrawLines(_iceI_begin_DrawLines(lines, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_DrawLines(const ::Game::LineVector& lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_DrawLines(lines, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DrawLines(const ::Game::LineVector& lines, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawLines(lines, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DrawLines(const ::Game::LineVector& lines, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawLines(lines, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DrawLines(const ::Game::LineVector& lines, const ::Game::Callback_GameState_DrawLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawLines(lines, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DrawLines(const ::Game::LineVector& lines, const ::Ice::Context& context, const ::Game::Callback_GameState_DrawLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawLines(lines, context, cb, cookie);
    }

    void end_DrawLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_DrawLines(const ::Game::LineVector&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Game::ColorVector GetColors(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetColors(_iceI_begin_GetColors(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetColors(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetColors(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetColors(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetColors(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetColors(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetColors(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetColors(const ::Game::Callback_GameState_GetColorsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetColors(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetColors(const ::Ice::Context& context, const ::Game::Callback_GameState_GetColorsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetColors(context, cb, cookie);
    }

    ::Game::ColorVector end_GetColors(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetColors(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void DrawColors(const ::Game::ColorVector& colors, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_DrawColors(_iceI_begin_DrawColors(colors, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_DrawColors(const ::Game::ColorVector& colors, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_DrawColors(colors, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DrawColors(const ::Game::ColorVector& colors, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawColors(colors, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DrawColors(const ::Game::ColorVector& colors, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawColors(colors, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DrawColors(const ::Game::ColorVector& colors, const ::Game::Callback_GameState_DrawColorsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawColors(colors, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DrawColors(const ::Game::ColorVector& colors, const ::Ice::Context& context, const ::Game::Callback_GameState_DrawColorsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DrawColors(colors, context, cb, cookie);
    }

    void end_DrawColors(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_DrawColors(const ::Game::ColorVector&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool CheckWord(const ::std::string& word, ::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_CheckWord(_iceI_begin_CheckWord(word, id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_CheckWord(const ::std::string& word, ::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_CheckWord(word, id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CheckWord(const ::std::string& word, ::Ice::Int id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckWord(word, id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckWord(const ::std::string& word, ::Ice::Int id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckWord(word, id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckWord(const ::std::string& word, ::Ice::Int id, const ::Game::Callback_GameState_CheckWordPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckWord(word, id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckWord(const ::std::string& word, ::Ice::Int id, const ::Ice::Context& context, const ::Game::Callback_GameState_CheckWordPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckWord(word, id, context, cb, cookie);
    }

    bool end_CheckWord(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_CheckWord(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Game::Players GetPlayers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetPlayers(_iceI_begin_GetPlayers(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetPlayers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetPlayers(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetPlayers(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetPlayers(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetPlayers(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetPlayers(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetPlayers(const ::Game::Callback_GameState_GetPlayersPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetPlayers(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetPlayers(const ::Ice::Context& context, const ::Game::Callback_GameState_GetPlayersPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetPlayers(context, cb, cookie);
    }

    ::Game::Players end_GetPlayers(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetPlayers(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Game
{

class GameState : public virtual ::Ice::Object
{
public:

    typedef GameStatePrx ProxyType;
    typedef GameStatePtr PointerType;

    virtual ~GameState();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void printString(const ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_printString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int AddPlayer(const ::std::string& name, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_AddPlayer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void IncrementScore(::Ice::Int id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_IncrementScore(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int GetScore(::Ice::Int id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetScore(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int GetNumPlayers(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetNumPlayers(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual GameInfo GetGameInfo(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetGameInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LineVector GetLines(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DrawLines(const LineVector& lines, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_DrawLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ColorVector GetColors(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetColors(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DrawColors(const ColorVector& colors, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_DrawColors(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool CheckWord(const ::std::string& word, ::Ice::Int id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_CheckWord(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Players GetPlayers(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetPlayers(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const GameState& lhs, const GameState& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const GameState& lhs, const GameState& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Game::Pair>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Game::Pair, S>
{
    static void write(S* ostr, const ::Game::Pair& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
    }
};

template<typename S>
struct StreamReader< ::Game::Pair, S>
{
    static void read(S* istr, ::Game::Pair& v)
    {
        istr->read(v.x);
        istr->read(v.y);
    }
};

template<>
struct StreamableTraits< ::Game::GameInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Game::GameInfo, S>
{
    static void write(S* ostr, const ::Game::GameInfo& v)
    {
        ostr->write(v.numplayers);
        ostr->write(v.currplayer);
        ostr->write(v.inprogress);
        ostr->write(v.changedturn);
        ostr->write(v.word);
        ostr->write(v.hint);
        ostr->write(v.time);
        ostr->write(v.round);
    }
};

template<typename S>
struct StreamReader< ::Game::GameInfo, S>
{
    static void read(S* istr, ::Game::GameInfo& v)
    {
        istr->read(v.numplayers);
        istr->read(v.currplayer);
        istr->read(v.inprogress);
        istr->read(v.changedturn);
        istr->read(v.word);
        istr->read(v.hint);
        istr->read(v.time);
        istr->read(v.round);
    }
};

template<>
struct StreamableTraits< ::Game::Player>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Game::Player, S>
{
    static void write(S* ostr, const ::Game::Player& v)
    {
        ostr->write(v.score);
        ostr->write(v.name);
        ostr->write(v.lastguess);
        ostr->write(v.guessed);
    }
};

template<typename S>
struct StreamReader< ::Game::Player, S>
{
    static void read(S* istr, ::Game::Player& v)
    {
        istr->read(v.score);
        istr->read(v.name);
        istr->read(v.lastguess);
        istr->read(v.guessed);
    }
};

}
/// \endcond

namespace Game
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_printString.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_printString.
 */
template<class T>
class CallbackNC_GameState_printString : public Callback_GameState_printString_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameState_printString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T> Callback_GameState_printStringPtr
newCallback_GameState_printString(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_printString<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T> Callback_GameState_printStringPtr
newCallback_GameState_printString(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_printString<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T> Callback_GameState_printStringPtr
newCallback_GameState_printString(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_printString<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T> Callback_GameState_printStringPtr
newCallback_GameState_printString(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_printString<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_printString.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_printString.
 */
template<class T, typename CT>
class Callback_GameState_printString : public Callback_GameState_printString_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameState_printString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T, typename CT> Callback_GameState_printStringPtr
newCallback_GameState_printString(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_printString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T, typename CT> Callback_GameState_printStringPtr
newCallback_GameState_printString(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_printString<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T, typename CT> Callback_GameState_printStringPtr
newCallback_GameState_printString(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_printString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_printString.
 */
template<class T, typename CT> Callback_GameState_printStringPtr
newCallback_GameState_printString(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_printString<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_AddPlayer.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_AddPlayer.
 */
template<class T>
class CallbackNC_GameState_AddPlayer : public Callback_GameState_AddPlayer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_GameState_AddPlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_AddPlayer(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_AddPlayer.
 */
template<class T> Callback_GameState_AddPlayerPtr
newCallback_GameState_AddPlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_AddPlayer<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_AddPlayer.
 */
template<class T> Callback_GameState_AddPlayerPtr
newCallback_GameState_AddPlayer(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_AddPlayer<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_AddPlayer.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_AddPlayer.
 */
template<class T, typename CT>
class Callback_GameState_AddPlayer : public Callback_GameState_AddPlayer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_GameState_AddPlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_AddPlayer(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_AddPlayer.
 */
template<class T, typename CT> Callback_GameState_AddPlayerPtr
newCallback_GameState_AddPlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_AddPlayer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_AddPlayer.
 */
template<class T, typename CT> Callback_GameState_AddPlayerPtr
newCallback_GameState_AddPlayer(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_AddPlayer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_IncrementScore.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_IncrementScore.
 */
template<class T>
class CallbackNC_GameState_IncrementScore : public Callback_GameState_IncrementScore_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameState_IncrementScore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_IncrementScore<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_IncrementScore<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_IncrementScore<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_IncrementScore<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_IncrementScore.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_IncrementScore.
 */
template<class T, typename CT>
class Callback_GameState_IncrementScore : public Callback_GameState_IncrementScore_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameState_IncrementScore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T, typename CT> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_IncrementScore<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T, typename CT> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_IncrementScore<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T, typename CT> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_IncrementScore<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_IncrementScore.
 */
template<class T, typename CT> Callback_GameState_IncrementScorePtr
newCallback_GameState_IncrementScore(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_IncrementScore<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_GetScore.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetScore.
 */
template<class T>
class CallbackNC_GameState_GetScore : public Callback_GameState_GetScore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_GameState_GetScore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_GetScore(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetScore.
 */
template<class T> Callback_GameState_GetScorePtr
newCallback_GameState_GetScore(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetScore<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetScore.
 */
template<class T> Callback_GameState_GetScorePtr
newCallback_GameState_GetScore(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetScore<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_GetScore.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetScore.
 */
template<class T, typename CT>
class Callback_GameState_GetScore : public Callback_GameState_GetScore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_GameState_GetScore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_GetScore(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetScore.
 */
template<class T, typename CT> Callback_GameState_GetScorePtr
newCallback_GameState_GetScore(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetScore<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetScore.
 */
template<class T, typename CT> Callback_GameState_GetScorePtr
newCallback_GameState_GetScore(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetScore<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_GetNumPlayers.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetNumPlayers.
 */
template<class T>
class CallbackNC_GameState_GetNumPlayers : public Callback_GameState_GetNumPlayers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_GameState_GetNumPlayers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_GetNumPlayers(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetNumPlayers.
 */
template<class T> Callback_GameState_GetNumPlayersPtr
newCallback_GameState_GetNumPlayers(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetNumPlayers<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetNumPlayers.
 */
template<class T> Callback_GameState_GetNumPlayersPtr
newCallback_GameState_GetNumPlayers(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetNumPlayers<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_GetNumPlayers.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetNumPlayers.
 */
template<class T, typename CT>
class Callback_GameState_GetNumPlayers : public Callback_GameState_GetNumPlayers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_GameState_GetNumPlayers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_GetNumPlayers(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetNumPlayers.
 */
template<class T, typename CT> Callback_GameState_GetNumPlayersPtr
newCallback_GameState_GetNumPlayers(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetNumPlayers<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetNumPlayers.
 */
template<class T, typename CT> Callback_GameState_GetNumPlayersPtr
newCallback_GameState_GetNumPlayers(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetNumPlayers<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_GetGameInfo.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetGameInfo.
 */
template<class T>
class CallbackNC_GameState_GetGameInfo : public Callback_GameState_GetGameInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const GameInfo&);

    CallbackNC_GameState_GetGameInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        GameInfo ret;
        try
        {
            ret = proxy->end_GetGameInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetGameInfo.
 */
template<class T> Callback_GameState_GetGameInfoPtr
newCallback_GameState_GetGameInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const GameInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetGameInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetGameInfo.
 */
template<class T> Callback_GameState_GetGameInfoPtr
newCallback_GameState_GetGameInfo(T* instance, void (T::*cb)(const GameInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetGameInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_GetGameInfo.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetGameInfo.
 */
template<class T, typename CT>
class Callback_GameState_GetGameInfo : public Callback_GameState_GetGameInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const GameInfo&, const CT&);

    Callback_GameState_GetGameInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        GameInfo ret;
        try
        {
            ret = proxy->end_GetGameInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetGameInfo.
 */
template<class T, typename CT> Callback_GameState_GetGameInfoPtr
newCallback_GameState_GetGameInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const GameInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetGameInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetGameInfo.
 */
template<class T, typename CT> Callback_GameState_GetGameInfoPtr
newCallback_GameState_GetGameInfo(T* instance, void (T::*cb)(const GameInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetGameInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_GetLines.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetLines.
 */
template<class T>
class CallbackNC_GameState_GetLines : public Callback_GameState_GetLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LineVector&);

    CallbackNC_GameState_GetLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        LineVector ret;
        try
        {
            ret = proxy->end_GetLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetLines.
 */
template<class T> Callback_GameState_GetLinesPtr
newCallback_GameState_GetLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const LineVector&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetLines.
 */
template<class T> Callback_GameState_GetLinesPtr
newCallback_GameState_GetLines(T* instance, void (T::*cb)(const LineVector&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_GetLines.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetLines.
 */
template<class T, typename CT>
class Callback_GameState_GetLines : public Callback_GameState_GetLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LineVector&, const CT&);

    Callback_GameState_GetLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        LineVector ret;
        try
        {
            ret = proxy->end_GetLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetLines.
 */
template<class T, typename CT> Callback_GameState_GetLinesPtr
newCallback_GameState_GetLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const LineVector&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetLines.
 */
template<class T, typename CT> Callback_GameState_GetLinesPtr
newCallback_GameState_GetLines(T* instance, void (T::*cb)(const LineVector&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_DrawLines.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_DrawLines.
 */
template<class T>
class CallbackNC_GameState_DrawLines : public Callback_GameState_DrawLines_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameState_DrawLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawLines<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawLines<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_DrawLines.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_DrawLines.
 */
template<class T, typename CT>
class Callback_GameState_DrawLines : public Callback_GameState_DrawLines_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameState_DrawLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T, typename CT> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T, typename CT> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T, typename CT> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawLines.
 */
template<class T, typename CT> Callback_GameState_DrawLinesPtr
newCallback_GameState_DrawLines(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_GetColors.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetColors.
 */
template<class T>
class CallbackNC_GameState_GetColors : public Callback_GameState_GetColors_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ColorVector&);

    CallbackNC_GameState_GetColors(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ColorVector ret;
        try
        {
            ret = proxy->end_GetColors(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetColors.
 */
template<class T> Callback_GameState_GetColorsPtr
newCallback_GameState_GetColors(const IceUtil::Handle<T>& instance, void (T::*cb)(const ColorVector&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetColors<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetColors.
 */
template<class T> Callback_GameState_GetColorsPtr
newCallback_GameState_GetColors(T* instance, void (T::*cb)(const ColorVector&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetColors<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_GetColors.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetColors.
 */
template<class T, typename CT>
class Callback_GameState_GetColors : public Callback_GameState_GetColors_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ColorVector&, const CT&);

    Callback_GameState_GetColors(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        ColorVector ret;
        try
        {
            ret = proxy->end_GetColors(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetColors.
 */
template<class T, typename CT> Callback_GameState_GetColorsPtr
newCallback_GameState_GetColors(const IceUtil::Handle<T>& instance, void (T::*cb)(const ColorVector&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetColors<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetColors.
 */
template<class T, typename CT> Callback_GameState_GetColorsPtr
newCallback_GameState_GetColors(T* instance, void (T::*cb)(const ColorVector&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetColors<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_DrawColors.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_DrawColors.
 */
template<class T>
class CallbackNC_GameState_DrawColors : public Callback_GameState_DrawColors_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameState_DrawColors(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawColors<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawColors<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawColors<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_DrawColors<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_DrawColors.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_DrawColors.
 */
template<class T, typename CT>
class Callback_GameState_DrawColors : public Callback_GameState_DrawColors_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameState_DrawColors(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T, typename CT> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawColors<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T, typename CT> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawColors<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T, typename CT> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawColors<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_DrawColors.
 */
template<class T, typename CT> Callback_GameState_DrawColorsPtr
newCallback_GameState_DrawColors(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_DrawColors<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_CheckWord.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_CheckWord.
 */
template<class T>
class CallbackNC_GameState_CheckWord : public Callback_GameState_CheckWord_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_GameState_CheckWord(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_CheckWord(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_CheckWord.
 */
template<class T> Callback_GameState_CheckWordPtr
newCallback_GameState_CheckWord(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_CheckWord<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_CheckWord.
 */
template<class T> Callback_GameState_CheckWordPtr
newCallback_GameState_CheckWord(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_CheckWord<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_CheckWord.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_CheckWord.
 */
template<class T, typename CT>
class Callback_GameState_CheckWord : public Callback_GameState_CheckWord_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_GameState_CheckWord(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_CheckWord(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_CheckWord.
 */
template<class T, typename CT> Callback_GameState_CheckWordPtr
newCallback_GameState_CheckWord(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_CheckWord<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_CheckWord.
 */
template<class T, typename CT> Callback_GameState_CheckWordPtr
newCallback_GameState_CheckWord(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_CheckWord<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Game::GameState::begin_GetPlayers.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetPlayers.
 */
template<class T>
class CallbackNC_GameState_GetPlayers : public Callback_GameState_GetPlayers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Players&);

    CallbackNC_GameState_GetPlayers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        Players ret;
        try
        {
            ret = proxy->end_GetPlayers(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetPlayers.
 */
template<class T> Callback_GameState_GetPlayersPtr
newCallback_GameState_GetPlayers(const IceUtil::Handle<T>& instance, void (T::*cb)(const Players&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetPlayers<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetPlayers.
 */
template<class T> Callback_GameState_GetPlayersPtr
newCallback_GameState_GetPlayers(T* instance, void (T::*cb)(const Players&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameState_GetPlayers<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Game::GameState::begin_GetPlayers.
 * Create a wrapper instance by calling ::Game::newCallback_GameState_GetPlayers.
 */
template<class T, typename CT>
class Callback_GameState_GetPlayers : public Callback_GameState_GetPlayers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Players&, const CT&);

    Callback_GameState_GetPlayers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GameStatePrx proxy = GameStatePrx::uncheckedCast(result->getProxy());
        Players ret;
        try
        {
            ret = proxy->end_GetPlayers(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetPlayers.
 */
template<class T, typename CT> Callback_GameState_GetPlayersPtr
newCallback_GameState_GetPlayers(const IceUtil::Handle<T>& instance, void (T::*cb)(const Players&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetPlayers<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Game::GameState::begin_GetPlayers.
 */
template<class T, typename CT> Callback_GameState_GetPlayersPtr
newCallback_GameState_GetPlayers(T* instance, void (T::*cb)(const Players&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameState_GetPlayers<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
